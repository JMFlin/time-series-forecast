select(date, value.lag), by = c("date"))
new.data.tbl
new.data.tbl <- inner_join(new.data.tbl, forecast.data.cleaned %>%
mutate(date = floor_date(date + months(optimal.lag.setting, abbreviate = FALSE), unit = "month")) %>%
mutate(value.lag = unit) %>%
select(date, value.lag), by = c("date")) %>%
select(-c(index, diff)
pred <- predict(automl.leader, newdata = select(new.data.tbl , -c(index, diff)))
}
# Make future index
new.data.tbl <- forecast.idx %>%
tk_make_future_timeseries(n_future = 12) %>%
tk_get_timeseries_signature() %>%
slice(n) %>%
mutate(date = index) %>%
select(-diff, -index) %>%
clean_names()
new.data.tbl <- inner_join(new.data.tbl, forecast.data.cleaned %>%
mutate(date = floor_date(date + months(optimal.lag.setting, abbreviate = FALSE), unit = "month")) %>%
mutate(value.lag = unit) %>%
select(date, value.lag), by = c("date")) %>%
select(-c(index, diff))
new.data.tbl <- inner_join(new.data.tbl, forecast.data.cleaned %>%
mutate(date = floor_date(date + months(optimal.lag.setting, abbreviate = FALSE), unit = "month")) %>%
mutate(value.lag = unit) %>%
select(date, value.lag), by = c("date")) %>%
select(-c(index_num))
new.data.tbl
ncol(forecast.data.cleaned)
new.data.tbl <- inner_join(new.data.tbl, forecast.data.cleaned %>%
mutate(date = floor_date(date + months(optimal.lag.setting, abbreviate = FALSE), unit = "month")) %>%
mutate(value.lag = unit) %>%
select(date, value.lag), by = c("date")) %>%
select(-c(index_num)) %>%
select_if(~ !is.Date(.))
new.data.tbl
new.data.tbl$date
# Make future index
new.data.tbl <- forecast.idx %>%
tk_make_future_timeseries(n_future = 12) %>%
tk_get_timeseries_signature() %>%
slice(n) %>%
mutate(date = index) %>%
select(-diff, -index) %>%
clean_names()
new.data.tbl <- inner_join(new.data.tbl, forecast.data.cleaned %>%
mutate(date = as.Date(floor_date(date + months(optimal.lag.setting, abbreviate = FALSE), unit = "month"))) %>%
mutate(value.lag = unit) %>%
select(date, value.lag), by = c("date")) %>%
select(-c(index_num)) %>%
select_if(~ !is.Date(.))
new.data.tbl
LoadData <- function(unit){
forecast.data <- tq_get("S4248SM144NCEN", get = "economic.data", from = "2010-01-01", to = "2017-12-31")
forecast.data <- forecast.data %>%
rename(!!unit := price)
return(forecast.data)
}
TidyAcf <- function(forecast.data, value, lags = 0:20) {
acf.values <- forecast.data %>%
pull(unit) %>%
acf(lag.max = tail(lags, 1), plot = FALSE) %>%
.$acf %>%
.[,,1]
ret <- tibble(acf = acf.values) %>%
rowid_to_column(var = "lag") %>%
mutate(lag = lag - 1) %>%
filter(lag %in% lags)
return(ret)
}
InitialPlot <- function(forecast.data, data.frequency){
if (data.frequency == "month") {
breaks <- "1 year"
}else if (data.frequency == "week") {
breaks <- "4 month"
}else if (data.frequency == "day") {
breaks <- "1 month"
}
forecast.data %>%
ggplot(aes(date, unit)) +
geom_line(col = palette_light()[1]) +
geom_point(col = palette_light()[1]) +
geom_ma(ma_fun = SMA, n = 12, size = 1) +
theme_tq() +
#scale_x_date(date_breaks = breaks, date_labels = "%Y") +
labs(title = "Time series to forecast")
}
h2o.init()        # Fire up h2o
#unit <- "unit"
n <- c(1, 2, 3)
flog.info("Loading data")
forecast.data <- LoadData("unit")
#SEE SCALE
data.frequency <- forecast.data %>%
tk_index() %>%
tk_get_timeseries_summary() %>%
select(scale)
if (data.frequency == "month") {
max.lag <- 12 * 3
}else if (data.frequency == "week") {
max.lag <- 52 + (52*0.5)
}else if (data.frequency == "day") {
max.lag <- 365
}
flog.info("Plotting time series")
InitialPlot(forecast.data, data.frequency)
flog.info("Augmenting data")
forecast.data.augmented <- forecast.data %>%
tk_augment_timeseries_signature() %>%
select(-diff)
flog.info("Cleaning data")
forecast.data.cleaned <- forecast.data.augmented %>%
clean_names() %>%
remove_empty(c("cols")) %>%
select_if(~ !any(is.na(.))) %>%
mutate_if(is.ordered, ~ as.character(.) %>% as.factor)
flog.info("Finding optimal lag")
optimal.lag.setting <- forecast.data.cleaned %>%
TidyAcf(unit, lags = 1:max.lag) %>%
filter(acf == max(acf)) %>%
pull(lag)
flog.info("Plotting ACF")
forecast.data.cleaned %>%
TidyAcf(unit, lags = 1:max.lag) %>%
ggplot(aes(lag, acf)) +
geom_vline(xintercept = optimal.lag.setting, size = 3, color = palette_light()[[2]]) +
geom_segment(aes(xend = lag, yend = 0), color = palette_light()[[1]]) +
geom_point(color = palette_light()[[1]], size = 2) +
geom_label(aes(label = acf %>% round(2)),
vjust = -1, color = palette_light()[[1]]) +
theme_tq() +
labs(title = "ACF")
flog.info("Inserting optimal lag into feature data")
forecast.data.lagged <- forecast.data.cleaned %>%
mutate(value.lag = lag(unit, n = optimal.lag.setting)) %>%
filter(!is.na(value.lag))
flog.info("Plotting training strategy for h2o")
TrainingStrategy(forecast.data.lagged)
source("R/evaluate.R")
source("R/predict.R")
TrainingStrategy(forecast.data.lagged)
flog.info("Starting predictions for h2o")
ModelH2O <- function(forecast.data.lagged){
tibble.list <- list()
idx <- forecast.data.lagged %>%
tk_index()
for (i in 1:6) {
flog.info(glue("Starting h2o modeling for ", as.character(max(idx) - months(6, abbreviate = FALSE) + months(i, abbreviate = FALSE))))
flog.info("Spliting into training, validation and test sets")
# Split into training, validation and test sets
train.tbl <- forecast.data.lagged %>%
filter(forecast.data.lagged$date < (max(forecast.data.lagged$date) - years(1))) %>%
select_if(~ !is.Date(.))
valid.tbl <- forecast.data.lagged %>%
filter(forecast.data.lagged$date > (max(forecast.data.lagged$date) - years(1)) &
forecast.data.lagged$date < (max(forecast.data.lagged$date) - months(6, abbreviate = FALSE))) %>%
select_if(~ !is.Date(.))
test.tbl <- forecast.data.lagged %>%
filter(forecast.data.lagged$date == (max(forecast.data.lagged$date) - months(6, abbreviate = FALSE) + months(i, abbreviate = FALSE)))
# Retrieves the timestamp information
forecast.idx <- test.tbl %>%
tk_index()
test.tbl <- test.tbl %>%
select_if(~ !is.Date(.))
##
#remove near zero var cols
##
flog.info("Converting to h2oframe objects")
# Convert to H2OFrame objects
train.h2o <- as.h2o(train.tbl)
valid.h2o <- as.h2o(valid.tbl)
test.h2o  <- as.h2o(test.tbl)
x <- setdiff(names(train.h2o), "unit")
flog.info("Starting h2o.automl")
automl.models.h2o <- h2o.automl(
x = x,
y = "unit",
training_frame = train.h2o,
validation_frame = valid.h2o,
leaderboard_frame = test.h2o,
max_runtime_secs = 60,
stopping_metric = "deviance")
flog.info("Extract leader model")
# Extract leader model
automl.leader <- automl.models.h2o@leader
# Make predictions
pred.h2o <- h2o.predict(automl.leader, newdata = test.h2o)
# Predictions with timestamps
predictions.tbl <- tibble(
date  = forecast.idx,
pred = as.vector(pred.h2o)
)
flog.info("Appending predictions")
# Append predictions
tibble.list[[i]] <- predictions.tbl
}
flog.info("Collapsing tibbles")
predictions.tbl <- bind_rows(tibble.list)
return(list(predictions.tbl, automl.leader))
}
list[predictions.tbl.h2o, automl.leader] <- ModelH2O(forecast.data.lagged)
ModelLM <- function(forecast.data.lagged){
tibble.list <- list()
idx <- forecast.data.lagged %>%
tk_index()
for (i in 1:6) {
flog.info(glue("Startting lm modeling for ", as.character(max(idx) - months(6, abbreviate = FALSE) + months(i, abbreviate = FALSE))))
flog.info("Splitting data into training, validation and test sets")
# Split into training, validation and test sets
train.tbl <- forecast.data.lagged %>%
filter(date < (max(date) - months(6, abbreviate = FALSE))) %>%
select_if(~ !is.Date(.))
test.tbl <- forecast.data.lagged %>%
filter(date == (max(date) - months(6, abbreviate = FALSE) + months(i, abbreviate = FALSE)))
# Retrieves the timestamp information
forecast.idx <- test.tbl %>%
tk_index()
test.tbl <- test.tbl %>%
select_if(~ !is.Date(.))
##
#remove near zero var cols
##
fit.lm <- lm(unit ~ ., data = train.tbl)
# Make predictions
pred <- predict(fit.lm, newdata = test.tbl)
# Predictions with timestamps
predictions.tbl <- tibble(
date  = forecast.idx,
pred = as.vector(pred)
)
flog.info("Appending predictions")
# Append predictions
tibble.list[[i]] <- predictions.tbl
}
flog.info("Collapsing tibbles")
predictions.tbl.lm <- bind_rows(tibble.list)
return(list(predictions.tbl.lm, fit.lm))
}
flog.info("Starting predictions for lm")
predictions.tbl.lm <- ModelLM(forecast.data.lagged)
list[predictions.tbl.lm, fit.lm] <- ModelLM(forecast.data.lagged)
LM.model <- ModelLM(forecast.data.lagged)
LM.model
ModelLM <- function(forecast.data.lagged){
tibble.list <- list()
idx <- forecast.data.lagged %>%
tk_index()
for (i in 1:6) {
flog.info(glue("Startting lm modeling for ", as.character(max(idx) - months(6, abbreviate = FALSE) + months(i, abbreviate = FALSE))))
flog.info("Splitting data into training, validation and test sets")
# Split into training, validation and test sets
train.tbl <- forecast.data.lagged %>%
filter(date < (max(date) - months(6, abbreviate = FALSE))) %>%
select_if(~ !is.Date(.))
test.tbl <- forecast.data.lagged %>%
filter(date == (max(date) - months(6, abbreviate = FALSE) + months(i, abbreviate = FALSE)))
# Retrieves the timestamp information
forecast.idx <- test.tbl %>%
tk_index()
test.tbl <- test.tbl %>%
select_if(~ !is.Date(.))
##
#remove near zero var cols
##
fit.lm <- lm(unit ~ ., data = train.tbl)
# Make predictions
pred <- predict(fit.lm, newdata = test.tbl)
# Predictions with timestamps
predictions.tbl <- tibble(
date  = forecast.idx,
pred = as.vector(pred)
)
flog.info("Appending predictions")
# Append predictions
tibble.list[[i]] <- predictions.tbl
}
flog.info("Collapsing tibbles")
predictions.tbl.lm <- bind_rows(tibble.list)
LM.model <- list(predictions.tbl.lm = predictions.tbl.lm,
fit.lm = fit.lm)
return(LM.model)
}
LM.model <- ModelLM(forecast.data.lagged)
LM.model
LM.model$predictions.tbl.lm
error.tbl.lm <- Evaluate(LM.model$predictions.tbl.lm)
LM.model$predictions.tbl.lm
error.tbl.lm <- Evaluate(forecast.data, LM.model$predictions.tbl.lm)
Evaluate <- function(forecast.data, predictions.tbl){
# Investigate test error
error.tbl <- inner_join(forecast.data, predictions.tbl, by = "date") %>%
#add_column(pred = predictions.tbl %>% as.tibble() %>% pull(pred)) %>%
rename(actual = unit) %>%
mutate(
error     = actual - pred,
error.pct = error / actual
) %>%
summarise(
me   = mean(error),
rmse = mean(error^2)^0.5,
mae  = mean(abs(error)),
mape = mean(abs(error.pct)),
mpe  = mean(error.pct)
)
return(error.tbl)
}
error.tbl.lm <- Evaluate(forecast.data, LM.model$predictions.tbl.lm)
print(error.tbl.lm)
ActualVsPredicted(forecast.data, LM.model$predictions.tbl.lm)
# Retrieves the timestamp information
forecast.idx <- forecast.data %>%
tk_index()
# Make future index
new.data.tbl <- forecast.idx %>%
tk_make_future_timeseries(n_future = 12) %>%
tk_get_timeseries_signature() %>%
slice(n) %>%
mutate(date = index) %>%
select(-diff, -index) %>%
clean_names()
new.data.tbl <- inner_join(new.data.tbl, forecast.data.cleaned %>%
mutate(date = as.Date(floor_date(date + months(optimal.lag.setting, abbreviate = FALSE), unit = "month"))) %>%
mutate(value.lag = unit) %>%
select(date, value.lag), by = c("date")) %>%
select(-c(index_num)) %>%
select_if(~ !is.Date(.))
pred <- predict(LM.model$fit.lm, newdata = new.data.tbl)
new.data.tbl
LM.model$fit.lm$coefficients
forecast.data.lagged
?tk_augment_timeseries_signature
# Make future index
new.data.tbl <- forecast.idx %>%
tk_make_future_timeseries(n_future = 12) %>%
tk_get_timeseries_signature() %>%
slice(n) %>%
mutate(date = index) %>%
select(-diff, -index) %>%
clean_names()
new.data.tbl <- inner_join(new.data.tbl, forecast.data.cleaned %>%
mutate(date = as.Date(floor_date(date + months(optimal.lag.setting, abbreviate = FALSE), unit = "month"))) %>%
mutate(value.lag = unit) %>%
select(date, value.lag), by = c("date")) %>%
select_if(~ !is.Date(.))
pred <- predict(LM.model$fit.lm$coefficients, newdata = new.data.tbl)
pred <- predict(LM.model$fit.lm, newdata = new.data.tbl)
pred
forecast.idx
new.data.tbl
# Make future index
new.data.tbl <- forecast.idx %>%
tk_make_future_timeseries(n_future = 12) %>%
tk_get_timeseries_signature() %>%
slice(n) %>%
mutate(date = index) %>%
select(-diff, -index) %>%
clean_names()
feature.data.tbl <- inner_join(new.data.tbl, forecast.data.cleaned %>%
mutate(date = as.Date(floor_date(date + months(optimal.lag.setting, abbreviate = FALSE), unit = "month"))) %>%
mutate(value.lag = unit) %>%
select(date, value.lag), by = c("date")) %>%
select_if(~ !is.Date(.))
pred <- predict(LM.model$fit.lm, newdata = feature.data.tbl)
new.data.tbl
inner_join(new.data.tbl, forecast.data.cleaned %>%
mutate(date = as.Date(floor_date(date + months(optimal.lag.setting, abbreviate = FALSE), unit = "month"))) %>%
mutate(value.lag = unit) %>%
select(date, value.lag), by = c("date"))
feature.data.tbl %>%
mutate(date = inner_join(new.data.tbl, forecast.data.cleaned %>%
mutate(date = as.Date(floor_date(date + months(optimal.lag.setting, abbreviate = FALSE), unit = "month"))) %>%
mutate(value.lag = unit) %>%
select(date), by = c("date")))
# Make future index
new.data.tbl <- forecast.idx %>%
tk_make_future_timeseries(n_future = 12) %>%
tk_get_timeseries_signature() %>%
slice(n) %>%
mutate(date = index) %>%
select(-diff, -index) %>%
clean_names()
feature.data.tbl <- inner_join(new.data.tbl, forecast.data.cleaned %>%
mutate(date = as.Date(floor_date(date + months(optimal.lag.setting, abbreviate = FALSE), unit = "month"))) %>%
mutate(value.lag = unit) %>%
select(date, value.lag), by = c("date"))
pred <- predict(LM.model$fit.lm, newdata = feature.data.tbl %>%
select_if(~ !is.Date(.)))
final.tbl <- feature.data.tbl %>%
mutate(pred = pred) %>%
select(date, pred)
final.tbl
TrueForecasts <- function(forecast.data, predictions.tbl, final.tbl){
actuals.tbl <- forecast.data %>%
filter(predictions.tbl$date == forecast.data$date)
# Plot Beer Sales Forecast
forecast.data %>%
ggplot(aes(x = date, y = unit)) +
# Training data
geom_line(color = palette_light()[[1]]) +
geom_point(color = palette_light()[[1]]) +
# Predictions
geom_line(aes(y = pred), color = palette_light()[[2]], data = predictions.tbl) +
geom_point(aes(y = pred), color = palette_light()[[2]], data = predictions.tbl) +
# Actuals
geom_line(color = palette_light()[[1]], data = actuals.tbl) +
geom_point(color = palette_light()[[1]], data = actuals.tbl) +
# True
geom_line(aes(y = pred), color = palette_light()[[2]], data = final.tbl) +
geom_point(aes(y = pred), color = palette_light()[[2]], data = final.tbl) +
# Aesthetics
theme_tq() +
labs(title = "Forecast: Time Series Machine Learning",
subtitle = "Using basic multivariate linear regression can yield accurate results")
}
TrueForecasts(forecast.data, predictions.tbl, final.tbl)
TrueForecasts(forecast.data, LM.model$predictions.tbl.lm, final.tbl)
predictions.tbl
LM.model$predictions.tbl.lm
predictions.tbl <- LM.model$predictions.tbl.lm
predictions.tbl %>%
add_row(final.tbl)
final.tbl
predictions.tbl
predictions.tbl %>%
add_row(date = final.tbl$date, pred = final.tbl$pred)
predictions.tbl <- predictions.tbl %>%
add_row(date = final.tbl$date, pred = final.tbl$pred)
# Plot Beer Sales Forecast
forecast.data %>%
ggplot(aes(x = date, y = unit)) +
# Training data
geom_line(color = palette_light()[[1]]) +
geom_point(color = palette_light()[[1]]) +
# Actuals
geom_line(color = palette_light()[[1]], data = actuals.tbl) +
geom_point(color = palette_light()[[1]], data = actuals.tbl) +
# Predictions
geom_line(aes(y = pred), color = palette_light()[[2]], data = predictions.tbl) +
geom_point(aes(y = pred), color = palette_light()[[2]], data = predictions.tbl) +
# Aesthetics
theme_tq() +
labs(title = "Forecast: Time Series Machine Learning",
subtitle = "Using basic multivariate linear regression can yield accurate results")
actuals.tbl <- forecast.data %>%
filter(predictions.tbl$date == date)
predictions.tbl
predictions.tbl$date
actuals.tbl <- forecast.data %>%
filter(predictions.tbl$date %in% date)
forecast.data$date
predictions.tbl$date
forecast.data$date == predictions.tbl$date
forecast.data$date %in% predictions.tbl$date
actuals.tbl <- forecast.data %>%
filter(date %in% predictions.tbl$date)
actuals.tbl
forecast.data
predictions.tbl$date
actuals.tbl <- forecast.data %>%
filter(date %in% predictions.tbl$date)
predictions.tbl <- predictions.tbl %>%
add_row(date = final.tbl$date, pred = final.tbl$pred)
# Plot Beer Sales Forecast
forecast.data %>%
ggplot(aes(x = date, y = unit)) +
# Training data
geom_line(color = palette_light()[[1]]) +
geom_point(color = palette_light()[[1]]) +
# Actuals
geom_line(color = palette_light()[[1]], data = actuals.tbl) +
geom_point(color = palette_light()[[1]], data = actuals.tbl) +
# Predictions
geom_line(aes(y = pred), color = palette_light()[[2]], data = predictions.tbl) +
geom_point(aes(y = pred), color = palette_light()[[2]], data = predictions.tbl) +
# Aesthetics
theme_tq() +
labs(title = "Forecast: Time Series Machine Learning",
subtitle = "Using basic multivariate linear regression can yield accurate results")
# Plot Beer Sales Forecast
forecast.data %>%
ggplot(aes(x = date, y = unit)) +
# Training data
geom_line(color = palette_light()[[1]]) +
geom_point(color = palette_light()[[1]]) +
# Actuals
#geom_line(color = palette_light()[[1]], data = actuals.tbl) +
#geom_point(color = palette_light()[[1]], data = actuals.tbl) +
# Predictions
geom_line(aes(y = pred), color = palette_light()[[2]], data = predictions.tbl) +
geom_point(aes(y = pred), color = palette_light()[[2]], data = predictions.tbl) +
# Aesthetics
theme_tq() +
labs(title = "Forecast: Time Series Machine Learning",
subtitle = "Using basic multivariate linear regression can yield accurate results")
TrueForecasts <- function(forecast.data, predictions.tbl, final.tbl){
predictions.tbl <- predictions.tbl %>%
add_row(date = final.tbl$date, pred = final.tbl$pred)
# Plot Beer Sales Forecast
forecast.data %>%
ggplot(aes(x = date, y = unit)) +
# Training data
geom_line(color = palette_light()[[1]]) +
geom_point(color = palette_light()[[1]]) +
# Predictions
geom_line(aes(y = pred), color = palette_light()[[2]], data = predictions.tbl) +
geom_point(aes(y = pred), color = palette_light()[[2]], data = predictions.tbl) +
# Aesthetics
theme_tq() +
labs(title = "Forecast: Time Series Machine Learning",
subtitle = "Using basic multivariate linear regression can yield accurate results")
}
TrueForecasts(forecast.data, LM.model$predictions.tbl.lm, final.tbl)
