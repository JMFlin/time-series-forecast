rename(ds = date,
y = unit)
flog.info(glue(
"Training window: {min.train.date} - {max.train.date} "
))
flog.info(glue(
"Testing window: {min.test.date} - {max.test.date} "
))
# Retrieves the timestamp information
forecast.idx <- test.tbl %>%
tk_index()
prophet_model_test <- prophet(train.tbl,
growth = "linear", # growth curve trend
n.changepoints = 100, # Prophet automatically detects changes in trends by selecting changepoints from the data
yearly.seasonality = FALSE, # yearly seasonal component using Fourier series
weekly.seasonality = TRUE # weekly seasonal component using dummy variables
#holidays = off_days
)
train.tbl <- train.tbl %>%
rename(ds = date,
y = unit)
test.tbl <- test.tbl %>%
rename(ds = date,
y = unit)
flog.info(glue(
"Training window: {min.train.date} - {max.train.date} "
))
flog.info(glue(
"Testing window: {min.test.date} - {max.test.date} "
))
# Retrieves the timestamp information
forecast.idx <- test.tbl %>%
tk_index()
prophet_model_test <- prophet(train.tbl,
growth = "linear", # growth curve trend
n.changepoints = 100, # Prophet automatically detects changes in trends by selecting changepoints from the data
yearly.seasonality = FALSE, # yearly seasonal component using Fourier series
weekly.seasonality = TRUE # weekly seasonal component using dummy variables
#holidays = off_days
)
prophet_model_test <- prophet(train.tbl,
growth = "linear", # growth curve trend
#n.changepoints = 100, # Prophet automatically detects changes in trends by selecting changepoints from the data
yearly.seasonality = FALSE, # yearly seasonal component using Fourier series
weekly.seasonality = TRUE # weekly seasonal component using dummy variables
#holidays = off_days
)
prophet_model_test <- prophet(train.tbl,
growth = "linear", # growth curve trend
#n.changepoints = 100, # Prophet automatically detects changes in trends by selecting changepoints from the data
yearly.seasonality = TRUE, # yearly seasonal component using Fourier series
weekly.seasonality = TRUE # weekly seasonal component using dummy variables
#holidays = off_days
)
predict(prophet_model_test, test.tbl)
forecast <- predict(prophet_model_test, test.tbl)
prophet.model <- prophet(train.tbl,
growth = "linear", # growth curve trend
#n.changepoints = 100, # Prophet automatically detects changes in trends by selecting changepoints from the data
yearly.seasonality = TRUE, # yearly seasonal component using Fourier series
weekly.seasonality = TRUE # weekly seasonal component using dummy variables
#holidays = off_days
)
forecast <- predict(prophet.model, test.tbl)
forecast %>%
mutate(resid = y - yhat) %>%
ggplot(aes(x = ds, y = resid)) +
geom_hline(yintercept = 0, color = "red") +
geom_point(alpha = 0.5, color = palette_light()[[1]]) +
geom_smooth() +
theme_tq()
names(forecast)
pred.prophet <- predict(prophet.model, test.tbl)
# Predictions with timestamps
predictions.tbl <- tibble(
date = forecast.idx,
pred = pred.prophet
)
# Predictions with timestamps
predictions.tbl <- tibble(
date = forecast.idx,
pred = pred.prophet %>% select(yhat)
)
pred.prophet %>% select(yhat)
# Predictions with timestamps
predictions.tbl <- tibble(
date = forecast.idx,
pred = pred.prophet %>% select(yhat) %>% as_vector()
)
predictions.tbl
flog.info("Appending predictions")
tibble.list <- list()
for (i in 1:6) {
flog.info("Splitting data into train and test sets")
train.tbl <- forecast.data %>%
filter(date <= (max(date) - months(6, abbreviate = FALSE) + months(i - 1, abbreviate = FALSE)))
test.tbl <- forecast.data %>%
filter(date == (max(date) - months(6, abbreviate = FALSE) + months(i, abbreviate = FALSE)))
min.train.date <- min(as.Date(train.tbl$date))
max.train.date <- max(as.Date(train.tbl$date))
min.test.date <- min(as.Date(test.tbl$date))
max.test.date <- max(as.Date(test.tbl$date))
train.tbl <- train.tbl %>%
rename(ds = date,
y = unit)
test.tbl <- test.tbl %>%
rename(ds = date,
y = unit)
flog.info(glue(
"Training window: {min.train.date} - {max.train.date} "
))
flog.info(glue(
"Testing window: {min.test.date} - {max.test.date} "
))
# Retrieves the timestamp information
forecast.idx <- test.tbl %>%
tk_index()
prophet.model <- prophet(train.tbl,
growth = "linear", # growth curve trend
#n.changepoints = 100, # Prophet automatically detects changes in trends by selecting changepoints from the data
yearly.seasonality = TRUE, # yearly seasonal component using Fourier series
weekly.seasonality = TRUE # weekly seasonal component using dummy variables
#holidays = off_days
)
pred.prophet <- predict(prophet.model, test.tbl)
# Predictions with timestamps
predictions.tbl <- tibble(
date = forecast.idx,
pred = pred.prophet %>% select(yhat) %>% as_vector()
)
flog.info("Appending predictions")
# Append predictions
tibble.list[[i]] <- predictions.tbl
flog.info(glue("End of round {i}"))
flog.info("=================================================")
}
flog.info("Collapsing tibbles")
predictions.tbl.uni <- bind_rows(tibble.list)
prophet.model
PROPHET.model <- list(
predictions.tbl.uni = predictions.tbl.uni,
fit.prophet = prophet.model
)
PROPHET.model
PROPHET.model$predictions.tbl.uni
error.tbl.lm <- Evaluate(forecast.data.cleaned, PROPHET.model$predictions.tbl.uni)
print(error.tbl.lm)
flog.info("Plotting actual vs predicted")
ActualVsPredicted(forecast.data.cleaned, TS.model$predictions.tbl.uni)
ActualVsPredicted(forecast.data.cleaned, PROPHET.model$predictions.tbl.uni$predictions.tbl.uni)
ActualVsPredicted(forecast.data.cleaned, PROPHET.model$predictions.tbl.uni)
new.data.tbl <- forecast.data.cleaned %>%
tk_index() %>%
tk_make_future_timeseries(n_future = max(n))
flog.info(glue("Predicting {max(n)} steps ahead with prophet"))
test.tbl
future <- make_future_dataframe(PROPHET.model$fit.prophet, periods = max(n))
future
new.data.tbl
forecast <- predict(PROPHET.model$fit.prophet, new.data.tbl)
new.data.tbl <- forecast.data.cleaned %>%
tk_index() %>%
tk_make_future_timeseries(n_future = max(n)) %>%
class(future)
new.data.tbl <- forecast.data.cleaned %>%
tk_index() %>%
tk_make_future_timeseries(n_future = max(n)) %>%
class(future)
class(future)
new.data.tbl <- forecast.data.cleaned %>%
tk_index() %>%
tk_make_future_timeseries(n_future = max(n)) %>%
as_data_frame()
new.data.tbl
new.data.tbl <- forecast.data.cleaned %>%
tk_index() %>%
tk_make_future_timeseries(n_future = max(n)) %>%
as_data_frame() %>%
rename("ds" = value)
new.data.tbl
flog.info(glue("Predicting {max(n)} steps ahead with prophet"))
#future <- make_future_dataframe(PROPHET.model$fit.prophet, periods = max(n))
forecast <- predict(PROPHET.model$fit.prophet, new.data.tbl)
forecast
PROPHET.model$fit.prophet
plot(prophet_model_test, forecast) +
theme_tq()
final.tbl <- feature.data.tbl %>%
mutate(pred = pred.prophet) %>%
select(date, pred)
#future <- make_future_dataframe(PROPHET.model$fit.prophet, periods = max(n))
pred.prophet <- predict(PROPHET.model$fit.prophet, new.data.tbl)
pred.prophet
final.tbl <- pred.prophet %>%
mutate(pred = yhat, ds = date) %>%
select(date, pred)
final.tbl <- pred.prophet %>%
rename(pred = yhat, date = ds) %>%
select(date, pred)
final.tbl
flog.info("Plotting true forecasts for lm")
TrueForecasts(forecast.data.cleaned, PROPHET.model$predictions.tbl.uni, final.tbl)
# Predictions with timestamps
predictions.tbl <- tibble(
date = forecast.idx,
pred = pred.thief
)
flog.info(glue("Predicting {max(n)} steps ahead with prophet: {new.data.tbl$ds}"))
flog.info(glue("Predicting {max(n)} steps ahead with prophet: {new.data.tbl %>% select(ds)}"))
new.data.tbl
new.data.tbl %>% select(ds)
flog.info(glue("Predicting {max(n)} steps ahead with prophet: {new.data.tbl %>% select(ds) %>% as.character()}"))
new.data.tbl %>% select(ds) %>% as.character()
new.data.tbl %>% select(ds) %>% as.Date()
new.data.tbl %>% select(ds)
new.data.tbl %>% select(ds) %>% as_vector()
new.data.tbl %>% select(ds) %>% as.character()
new.data.tbl %>% select(ds)
new.data.tbl %>% select(ds) %>% as_data_frame() %>% as.character()
new.data.tbl %>% select(ds) %>% as_data_frame()
new.data.tbl %>% select(ds) %>% as.factor()
flog.info(glue("Predicting {min(n):max(n)} steps ahead with prophet: {new.data.tbl %>% select(ds) %>% as.character()}"))
flog.info(glue("Predicting {min(n):max(n)} steps ahead with prophet: {new.data.tbl %>% select(ds)}"))
new.data.tbl %>% select(ds)
flog.info(glue("Predicting {min(n):max(n)} steps ahead with prophet: {new.data.tbl %>% select(ds)}"))
flog.info(glue("Predicting {min(n):max(n)} steps ahead with prophet: {new.data.tbl}"))
flog.info(glue("Predicting {max(n)} steps ahead with prophet: {new.data.tbl %>% select(ds)}"))
flog.info(glue("Predicting {max(n)} steps ahead with prophet: {new.data.tbl$da}"))
flog.info(glue("Predicting {max(n)} steps ahead with prophet: {new.data.tbl$ds}"))
min(n):max(n)
1:max(n)
flog.info(glue("Predicting {1:max(n)} steps ahead with prophet: {new.data.tbl$ds}"))
flog.info("Finding frequency")
data.frequency <- forecast.data.cleaned %>%
tk_index() %>%
tk_get_timeseries_summary() %>%
select(scale) %>%
mutate(scale = ifelse(scale == "day", 365,
ifelse(scale == "week", 7,
ifelse(scale == "month", 12,
ifelse(scale == "year", 1, NA)
)
)
)) %>%
as_vector()
flog.info("Starting thief modeling")
PROPHET.model <- ModelProphet(forecast.data.cleaned, data.frequency)
flog.info("Investigating test error")
error.tbl.lm <- Evaluate(forecast.data.cleaned, PROPHET.model$predictions.tbl.uni)
ModelProphet <- function(forecast.data.cleaned, data.frequency) {
tibble.list <- list()
for (i in 1:6) {
flog.info("Splitting data into train and test sets")
train.tbl <- forecast.data %>%
filter(date <= (max(date) - months(6, abbreviate = FALSE) + months(i - 1, abbreviate = FALSE)))
test.tbl <- forecast.data %>%
filter(date == (max(date) - months(6, abbreviate = FALSE) + months(i, abbreviate = FALSE)))
min.train.date <- min(as.Date(train.tbl$date))
max.train.date <- max(as.Date(train.tbl$date))
min.test.date <- min(as.Date(test.tbl$date))
max.test.date <- max(as.Date(test.tbl$date))
train.tbl <- train.tbl %>%
rename(ds = date,
y = unit)
test.tbl <- test.tbl %>%
rename(ds = date,
y = unit)
flog.info(glue(
"Training window: {min.train.date} - {max.train.date} "
))
flog.info(glue(
"Testing window: {min.test.date} - {max.test.date} "
))
# Retrieves the timestamp information
forecast.idx <- test.tbl %>%
tk_index()
prophet.model <- prophet(train.tbl,
growth = "linear", # growth curve trend
#n.changepoints = 100, # Prophet automatically detects changes in trends by selecting changepoints from the data
yearly.seasonality = TRUE, # yearly seasonal component using Fourier series
weekly.seasonality = TRUE # weekly seasonal component using dummy variables
#holidays = off_days
)
pred.prophet <- predict(prophet.model, test.tbl)
# Predictions with timestamps
predictions.tbl <- tibble(
date = forecast.idx,
pred = pred.prophet %>% select(yhat) %>% as_vector()
)
flog.info("Appending predictions")
# Append predictions
tibble.list[[i]] <- predictions.tbl
flog.info(glue("End of round {i}"))
flog.info("=================================================")
}
flog.info("Collapsing tibbles")
predictions.tbl.uni <- bind_rows(tibble.list)
PROPHET.model <- list(
predictions.tbl.uni = predictions.tbl.uni,
fit.prophet = prophet.model
)
return(PROPHET.model)
}
flog.info("Finding frequency")
data.frequency <- forecast.data.cleaned %>%
tk_index() %>%
tk_get_timeseries_summary() %>%
select(scale) %>%
mutate(scale = ifelse(scale == "day", 365,
ifelse(scale == "week", 7,
ifelse(scale == "month", 12,
ifelse(scale == "year", 1, NA)
)
)
)) %>%
as_vector()
flog.info("Starting thief modeling")
PROPHET.model <- ModelProphet(forecast.data.cleaned, data.frequency)
flog.info("Investigating test error")
error.tbl.lm <- Evaluate(forecast.data.cleaned, PROPHET.model$predictions.tbl.uni)
print(error.tbl.lm)
flog.info("Plotting actual vs predicted")
ActualVsPredicted(forecast.data.cleaned, PROPHET.model$predictions.tbl.uni)
new.data.tbl <- forecast.data.cleaned %>%
tk_index() %>%
tk_make_future_timeseries(n_future = max(n)) %>%
as_data_frame() %>%
rename("ds" = value)
flog.info(glue("Predicting {1:max(n)} steps ahead with prophet: {new.data.tbl$ds}"))
pred.prophet <- predict(PROPHET.model$fit.prophet, new.data.tbl)
final.tbl <- pred.prophet %>%
rename(pred = yhat, date = ds) %>%
select(date, pred)
flog.info("Plotting true forecasts for prophet")
TrueForecasts(forecast.data.cleaned, PROPHET.model$predictions.tbl.uni, final.tbl)
stopCluster(cl)
rm(list = ls())
.rs.restartR()
setwd("C:/Users/janne/Documents/time-series-forecast")
# Load libraries
if (!require("pacman")) install.packages("pacman")
pacman::p_load(
"h2o", # Awesome ML Library
"timetk", # Toolkit for working with time series in R
"futile.logger", # Adds logging
"tidyquant", # Loads tidyverse, financial pkgs, used to get data
"janitor", # COlumn name handling
"glue", # A better paste function
"styler", # Style r code
"sweep", # Broom-style tidiers for the forecast package
"thief", # Forecasting models and predictions package
"caret", # Awesome ML Library
"doParallel", # Allow parallel processing with caret
"recipes" # Carry transformation to new data
)
file.sources <- list.files("utils",
pattern = "*.R$", full.names = TRUE,
ignore.case = TRUE
)
invisible(sapply(file.sources, source, .GlobalEnv))
n <- 3
unit.of.measurement <- "unit"
factor.limit <- 3
regression.control <- trainControl(
method = "cv",
number = 3
)
cl <- makeCluster(detectCores())
registerDoParallel(cl)
flog.info("Loading data")
forecast.data <- LoadData(unit.of.measurement)
data.frequency <- forecast.data %>%
tk_index() %>%
tk_get_timeseries_summary() %>%
select(scale)
flog.info("Plotting time series")
InitialPlot(forecast.data, data.frequency)
flog.info("Cleaning target data")
forecast.data.cleaned <- CleanTarget(forecast.data, data.frequency)
max.lag <<- round(nrow(forecast.data.cleaned) * 0.4)
optimal.lag.setting <<- forecast.data.cleaned %>%
TidyAcf(unit, lags = 1:max.lag) %>%
filter(acf == max(acf)) %>%
pull(lag)
flog.info("Plotting ACF")
AcfPlot(forecast.data.cleaned)
flog.info("Creating timetk features")
forecast.data.features <- CreateTimeTkFeatures(forecast.data.cleaned)
flog.info("Cleaning features data")
forecast.data.cleaned <- CleanFeatures(forecast.data.features)
flog.info("Starting multivariate modeling with lm")
MultivariateSeriesLM(forecast.data.cleaned)
flog.info("Plotting training strategy for h2o")
TrainingStrategy(forecast.data.cleaned)
flog.info("Starting predictions for h2o")
H2O.model <- ModelH2O(forecast.data.cleaned)
h2o.init() # Fire up h2o
h2o.no_progress() # Turn off output of progress bars
flog.info("Starting predictions for h2o")
H2O.model <- ModelH2O(forecast.data.cleaned)
flog.info("Investigating test error")
error.tbl.h2o <- Evaluate(forecast.data.cleaned, H2O.model$predictions.tbl.h2o)
print(error.tbl.h2o)
flog.info("Plotting acutal vs predicted")
ActualVsPredicted(forecast.data.cleaned, H2O.model$predictions.tbl.h2o)
flog.info("Ceating future data for prediction")
feature.data.tbl <- CreateFutureData(forecast.data.cleaned)
h2o.feature.data.tbl <- feature.data.tbl %>%
select_if(~ !is.Date(.))
#flog.info(glue("Predicting {1:max(n)} steps ahead with lm: {feature.data.tbl$date}"))
flog.info(glue("Predicting {max(n)} steps ahead with h2o"))
flog.info(glue("Predicting {1:max(n)} steps ahead with lm: {feature.data.tbl$date}"))
feature.data.tbl
flog.info(glue("Predicting {1:max(n)} steps with h2o: {feature.data.tbl$date}"))
pred.h2o <- predict(H2O.model$automl.leader, newdata = as.h2o(h2o.feature.data.tbl)) %>%
as.vector()
final.tbl <- feature.data.tbl %>%
mutate(pred = pred.h2o) %>%
select(date, pred)
flog.info("Plotting true forecasts for h2o")
TrueForecasts(forecast.data.cleaned, H2O.model$predictions.tbl.h2o, final.tbl)
usethis::use_tidy_style()
flog.info("Finding frequency")
data.frequency <- forecast.data.cleaned %>%
tk_index() %>%
tk_get_timeseries_summary() %>%
select(scale) %>%
mutate(scale = ifelse(scale == "day", 365,
ifelse(scale == "week", 7,
ifelse(scale == "month", 12,
ifelse(scale == "year", 1, NA)
)
)
)) %>%
as_vector()
flog.info("Starting thief modeling")
PROPHET.model <- ModelProphet(forecast.data.cleaned, data.frequency)
flog.info("Finding frequency")
data.frequency <- forecast.data.cleaned %>%
tk_index() %>%
tk_get_timeseries_summary() %>%
select(scale) %>%
mutate(scale = ifelse(scale == "day", 365,
ifelse(scale == "week", 7,
ifelse(scale == "month", 12,
ifelse(scale == "year", 1, NA)
)
)
)) %>%
as_vector()
flog.info("Starting univariate modeling")
tibble.list <- list()
i <- 1
flog.info("Splitting data into train and test sets")
train.tbl <- forecast.data %>%
filter(date <= (max(date) - months(6, abbreviate = FALSE) + months(i - 1, abbreviate = FALSE)))
test.tbl <- forecast.data %>%
filter(date == (max(date) - months(6, abbreviate = FALSE) + months(i, abbreviate = FALSE)))
flog.info("Converting to ts objects")
train.ts <- tk_ts(train.tbl$unit,
start = as.yearmon(glue(year(min(train.tbl$date)), "-0", month(min(train.tbl$date)))),
frequency = data.frequency
)
test.ts <- tk_ts(test.tbl$unit,
start = as.yearmon(glue(year(min(test.tbl$date)), "-0", month(min(test.tbl$date)))),
frequency = data.frequency
)
min.train.date <- min(as.Date(train.tbl$date))
max.train.date <- max(as.Date(train.tbl$date))
min.test.date <- min(as.Date(test.tbl$date))
max.test.date <- max(as.Date(test.tbl$date))
flog.info(glue(
"Training window: {min.train.date} - {max.train.date} "
))
flog.info(glue(
"Testing window: {min.test.date} - {max.test.date} "
))
# Retrieves the timestamp information
forecast.idx <- test.tbl %>%
tk_index()
flog.info("Starting training")
models.list <- list(
auto.arima = list(
y = train.ts,
max.p = optimal.lag.setting
),
ets = list(
y = train.ts
),
tbats = list(
y = train.ts
)
)
models.tbl <- enframe(models.list, name = "model_names", value = "params")
models.tbl.fit <- models.tbl %>%
mutate(fit = invoke_map(model_names, params))
models.tbl.fit %>%
mutate(tidy = map(fit, sw_tidy)) %>%
unnest(tidy) %>%
spread(key = model_names, value = estimate)
models.tbl.fit %>%
mutate(glance = map(fit, sw_glance)) %>%
unnest(glance, .drop = TRUE)
models.tbl.fit %>%
mutate(glance = map(fit, sw_glance)) %>%
unnest(glance, .drop = TRUE) %>%
arrange(desc(MAPE))
models.tbl.fit %>%
mutate(glance = map(fit, sw_glance)) %>%
unnest(glance, .drop = TRUE) %>%
arrange(desc(MAPE)) %>%
filter(row_number() == n())
