AcfPlot <- function(forecast.data.cleaned, optimal.lag.setting, max.lag) {
forecast.data.cleaned %>%
TidyAcf(unit, lags = 1:max.lag) %>%
ggplot(aes(lag, acf)) +
geom_vline(xintercept = optimal.lag.setting, size = 3, color = palette_light()[[2]]) +
geom_segment(aes(xend = lag, yend = 0), color = palette_light()[[1]]) +
geom_point(color = palette_light()[[1]], size = 2) +
geom_label(aes(label = acf %>% round(2)),
vjust = -1, color = palette_light()[[1]]
) +
theme_tq() +
labs(title = "ACF")
}
AcfPlot(forecast.data.cleaned, optimal.lag.setting, max.lag)
file.sources <- list.files("utils",
pattern = "*.R$", full.names = TRUE,
ignore.case = TRUE)
invisible(sapply(file.sources, source, .GlobalEnv))
n <- c(1, 2, 3)
TidyAcf <- function(forecast.data, value, lags = 0:20) {
acf.values <- forecast.data %>%
pull(unit) %>%
acf(lag.max = tail(lags, 1), plot = FALSE) %>%
.$acf %>%
.[, , 1]
ret <- tibble(acf = acf.values) %>%
rowid_to_column(var = "lag") %>%
mutate(lag = lag - 1) %>%
filter(lag %in% lags)
return(ret)
}
Main <- function() {
flog.info("Loading data")
forecast.data <- LoadData("unit")
# SEE SCALE
data.frequency <- forecast.data %>%
tk_index() %>%
tk_get_timeseries_summary() %>%
select(scale)
max.lag <- round(nrow(forecast.data) * 0.4)
flog.info("Plotting time series")
InitialPlot(forecast.data, data.frequency)
flog.info("Augmenting data")
forecast.data.augmented <- forecast.data %>%
tk_augment_timeseries_signature() %>%
select(-diff)
flog.info("Cleaning data")
forecast.data.cleaned <- forecast.data.augmented %>%
clean_names() %>%
remove_empty(c("cols")) %>%
select_if(~ !any(is.na(.))) %>%
mutate_if(is.ordered, ~ as.character(.) %>% as.factor())
flog.info("Finding optimal lag")
optimal.lag.setting <- forecast.data.cleaned %>%
TidyAcf(unit, lags = 1:max.lag) %>%
filter(acf == max(acf)) %>%
pull(lag)
flog.info("Plotting ACF")
AcfPlot(forecast.data.cleaned, optimal.lag.setting, max.lag)
flog.info("Inserting optimal lag into feature data")
forecast.data.lagged <- forecast.data.cleaned %>%
mutate(value.lag = lag(unit, n = optimal.lag.setting)) %>%
filter(!is.na(value.lag))
flog.info("Plotting training strategy for h2o")
TrainingStrategy(forecast.data.lagged)
flog.info("Starting predictions for h2o")
H2O.model <- ModelH2O(forecast.data.lagged)
flog.info("Investigating test error")
error.tbl.h2o <- Evaluate(forecast.data, H2O.model$predictions.tbl.h2o)
print(error.tbl.h2o)
ActualVsPredicted(forecast.data, H2O.model$predictions.tbl.h2o)
flog.info("Starting predictions for lm")
LM.model <- ModelLM(forecast.data.lagged)
flog.info("Investigating test error")
error.tbl.lm <- Evaluate(forecast.data, LM.model$predictions.tbl.lm)
print(error.tbl.lm)
flog.info("Plotting actual vs predicted")
ActualVsPredicted(forecast.data, LM.model$predictions.tbl.lm)
# Retrieves the timestamp information
forecast.idx <- forecast.data %>%
tk_index()
flog.info("Creating future time indexes")
# Make future index
new.data.tbl <- forecast.idx %>%
tk_make_future_timeseries(n_future = 12) %>%
tk_get_timeseries_signature() %>%
slice(n) %>%
mutate(date = index) %>%
select(-diff, -index) %>%
clean_names()
flog.info("Creating feature table")
feature.data.tbl <- inner_join(new.data.tbl, forecast.data.cleaned %>%
mutate(date = as.Date(floor_date(date + months(optimal.lag.setting, abbreviate = FALSE), unit = "month"))) %>%
mutate(value.lag = unit) %>%
select(date, value.lag), by = c("date"))
flog.info("Predcting with linear model")
pred.lm <- predict(LM.model$fit.lm, newdata = feature.data.tbl %>%
select_if(~ !is.Date(.)))
final.tbl <- feature.data.tbl %>%
mutate(pred = pred.lm) %>%
select(date, pred)
flog.info("Plotting true forecasts for lm")
TrueForecasts(forecast.data, LM.model$predictions.tbl.lm, final.tbl)
flog.info("Predcting with h2o model")
pred.h2o <- predict(H2O.model$automl.leader, newdata = feature.data.tbl %>%
select_if(~ !is.Date(.)))
final.tbl <- feature.data.tbl %>%
mutate(pred = pred.h2o) %>%
select(date, pred)
flog.info("Plotting true forecasts for h2o")
TrueForecasts(forecast.data, H2O.model$automl.leader, final.tbl)
}
Main()
# Load libraries
setwd("C:/Users/janne/Documents/time-series-forecast")
library(h2o) # Awesome ML Library
library(timetk) # Toolkit for working with time series in R
library(tidyquant) # Loads tidyverse, financial pkgs, used to get data
library(janitor)
library(glue)
library(futile.logger)
library(tsfeatures)
library(styler)
file.sources <- list.files("utils",
pattern = "*.R$", full.names = TRUE,
ignore.case = TRUE)
invisible(sapply(file.sources, source, .GlobalEnv))
h2o.init() # Fire up h2o
h2o.no_progress() # Turn off output of progress bars
n <- c(1, 2, 3)
TidyAcf <- function(forecast.data, value, lags = 0:20) {
acf.values <- forecast.data %>%
pull(unit) %>%
acf(lag.max = tail(lags, 1), plot = FALSE) %>%
.$acf %>%
.[, , 1]
ret <- tibble(acf = acf.values) %>%
rowid_to_column(var = "lag") %>%
mutate(lag = lag - 1) %>%
filter(lag %in% lags)
return(ret)
}
Main <- function() {
flog.info("Loading data")
forecast.data <- LoadData("unit")
# SEE SCALE
data.frequency <- forecast.data %>%
tk_index() %>%
tk_get_timeseries_summary() %>%
select(scale)
max.lag <- round(nrow(forecast.data) * 0.4)
flog.info("Plotting time series")
InitialPlot(forecast.data, data.frequency)
flog.info("Augmenting data")
forecast.data.augmented <- forecast.data %>%
tk_augment_timeseries_signature() %>%
select(-diff)
flog.info("Cleaning data")
forecast.data.cleaned <- forecast.data.augmented %>%
clean_names() %>%
remove_empty(c("cols")) %>%
select_if(~ !any(is.na(.))) %>%
mutate_if(is.ordered, ~ as.character(.) %>% as.factor())
flog.info("Finding optimal lag")
optimal.lag.setting <- forecast.data.cleaned %>%
TidyAcf(unit, lags = 1:max.lag) %>%
filter(acf == max(acf)) %>%
pull(lag)
flog.info("Plotting ACF")
AcfPlot(forecast.data.cleaned, optimal.lag.setting, max.lag)
flog.info("Inserting optimal lag into feature data")
forecast.data.lagged <- forecast.data.cleaned %>%
mutate(value.lag = lag(unit, n = optimal.lag.setting)) %>%
filter(!is.na(value.lag))
flog.info("Plotting training strategy for h2o")
TrainingStrategy(forecast.data.lagged)
flog.info("Starting predictions for h2o")
H2O.model <- ModelH2O(forecast.data.lagged)
flog.info("Investigating test error")
error.tbl.h2o <- Evaluate(forecast.data, H2O.model$predictions.tbl.h2o)
print(error.tbl.h2o)
ActualVsPredicted(forecast.data, H2O.model$predictions.tbl.h2o)
flog.info("Starting predictions for lm")
LM.model <- ModelLM(forecast.data.lagged)
flog.info("Investigating test error")
error.tbl.lm <- Evaluate(forecast.data, LM.model$predictions.tbl.lm)
print(error.tbl.lm)
flog.info("Plotting actual vs predicted")
ActualVsPredicted(forecast.data, LM.model$predictions.tbl.lm)
# Retrieves the timestamp information
forecast.idx <- forecast.data %>%
tk_index()
flog.info("Creating future time indexes")
# Make future index
new.data.tbl <- forecast.idx %>%
tk_make_future_timeseries(n_future = 12) %>%
tk_get_timeseries_signature() %>%
slice(n) %>%
mutate(date = index) %>%
select(-diff, -index) %>%
clean_names()
flog.info("Creating feature table")
feature.data.tbl <- inner_join(new.data.tbl, forecast.data.cleaned %>%
mutate(date = as.Date(floor_date(date + months(optimal.lag.setting, abbreviate = FALSE), unit = "month"))) %>%
mutate(value.lag = unit) %>%
select(date, value.lag), by = c("date"))
flog.info("Predcting with linear model")
pred.lm <- predict(LM.model$fit.lm, newdata = feature.data.tbl %>%
select_if(~ !is.Date(.)))
final.tbl <- feature.data.tbl %>%
mutate(pred = pred.lm) %>%
select(date, pred)
flog.info("Plotting true forecasts for lm")
TrueForecasts(forecast.data, LM.model$predictions.tbl.lm, final.tbl)
flog.info("Predcting with h2o model")
pred.h2o <- predict(H2O.model$automl.leader, newdata = as.h2o(feature.data.tbl %>%
select_if(~ !is.Date(.))))
final.tbl <- feature.data.tbl %>%
mutate(pred = pred.h2o) %>%
select(date, pred)
flog.info("Plotting true forecasts for h2o")
TrueForecasts(forecast.data, H2O.model$automl.leader, final.tbl)
}
flog.info("Loading data")
forecast.data <- LoadData("unit")
# SEE SCALE
data.frequency <- forecast.data %>%
tk_index() %>%
tk_get_timeseries_summary() %>%
select(scale)
max.lag <- round(nrow(forecast.data) * 0.4)
flog.info("Plotting time series")
InitialPlot(forecast.data, data.frequency)
flog.info("Augmenting data")
flog.info("Cleaning data")
forecast.data.augmented <- forecast.data %>%
tk_augment_timeseries_signature() %>%
select(-diff)
forecast.data.cleaned <- forecast.data.augmented %>%
clean_names() %>%
remove_empty(c("cols")) %>%
select_if(~ !any(is.na(.))) %>%
mutate_if(is.ordered, ~ as.character(.) %>% as.factor())
flog.info("Finding optimal lag")
optimal.lag.setting <- forecast.data.cleaned %>%
TidyAcf(unit, lags = 1:max.lag) %>%
filter(acf == max(acf)) %>%
pull(lag)
flog.info("Plotting ACF")
AcfPlot(forecast.data.cleaned, optimal.lag.setting, max.lag)
flog.info("Inserting optimal lag into feature data")
forecast.data.lagged <- forecast.data.cleaned %>%
mutate(value.lag = lag(unit, n = optimal.lag.setting)) %>%
filter(!is.na(value.lag))
flog.info("Plotting training strategy for h2o")
TrainingStrategy(forecast.data.lagged)
flog.info("Starting predictions for h2o")
H2O.model <- ModelH2O(forecast.data.lagged)
flog.info("Investigating test error")
error.tbl.h2o <- Evaluate(forecast.data, H2O.model$predictions.tbl.h2o)
print(error.tbl.h2o)
ActualVsPredicted(forecast.data, H2O.model$predictions.tbl.h2o)
flog.info("Starting predictions for lm")
LM.model <- ModelLM(forecast.data.lagged)
flog.info("Investigating test error")
error.tbl.lm <- Evaluate(forecast.data, LM.model$predictions.tbl.lm)
print(error.tbl.lm)
flog.info("Plotting actual vs predicted")
ActualVsPredicted(forecast.data, LM.model$predictions.tbl.lm)
# Retrieves the timestamp information
forecast.idx <- forecast.data %>%
tk_index()
flog.info("Creating future time indexes")
# Make future index
new.data.tbl <- forecast.idx %>%
tk_make_future_timeseries(n_future = 12) %>%
tk_get_timeseries_signature() %>%
slice(n) %>%
mutate(date = index) %>%
select(-diff, -index) %>%
clean_names()
flog.info("Creating feature table")
feature.data.tbl <- inner_join(new.data.tbl, forecast.data.cleaned %>%
mutate(date = as.Date(floor_date(date + months(optimal.lag.setting, abbreviate = FALSE), unit = "month"))) %>%
mutate(value.lag = unit) %>%
select(date, value.lag), by = c("date"))
flog.info("Predcting with linear model")
pred.lm <- predict(LM.model$fit.lm, newdata = feature.data.tbl %>%
select_if(~ !is.Date(.)))
final.tbl <- feature.data.tbl %>%
mutate(pred = pred.lm) %>%
select(date, pred)
flog.info("Plotting true forecasts for lm")
TrueForecasts(forecast.data, LM.model$predictions.tbl.lm, final.tbl)
flog.info("Predcting with h2o model")
pred.h2o <- predict(H2O.model$automl.leader, newdata = as.h2o(feature.data.tbl %>%
select_if(~ !is.Date(.))))
final.tbl <- feature.data.tbl %>%
mutate(pred = pred.h2o) %>%
select(date, pred)
flog.info("Plotting true forecasts for h2o")
TrueForecasts(forecast.data, H2O.model$automl.leader, final.tbl)
feature.data.tbl %>%
select_if(~ !is.Date(.)))
feature.data.tbl
feature.data.tbl %>%
select_if(~ !is.Date(.)))
h2o.feature.data.tbl <- feature.data.tbl %>%
select_if(~ !is.Date(.))
pred.h2o <- predict(H2O.model$automl.leader, newdata = as.h2o(h2o.feature.data.tbl))
h2o.feature.data.tbl
as.h2o(h2o.feature.data.tbl)
train.tbl
h2o.feature.data.tbl
names(h2o.feature.data.tbl)
tibble.list <- list()
i <- 1
flog.info("Splitting data into training, validation and test sets")
train.tbl <- forecast.data.lagged %>%
filter(forecast.data.lagged$date < (max(forecast.data.lagged$date) - years(1)) + months(i - 1, abbreviate = FALSE))
valid.tbl <- forecast.data.lagged %>%
filter(forecast.data.lagged$date >= (max(forecast.data.lagged$date) - years(1)) &
forecast.data.lagged$date <= (max(forecast.data.lagged$date) - months(6, abbreviate = FALSE) + months(i - 1, abbreviate = FALSE)))
test.tbl <- forecast.data.lagged %>%
filter(forecast.data.lagged$date == (max(forecast.data.lagged$date) - months(6, abbreviate = FALSE) + months(i, abbreviate = FALSE)))
min.train.date <- min(as.Date(train.tbl$date))
max.train.date <- max(as.Date(train.tbl$date))
min.valid.date <- min(as.Date(valid.tbl$date))
max.valid.date <- max(as.Date(valid.tbl$date))
min.test.date <- min(as.Date(test.tbl$date))
max.test.date <- max(as.Date(test.tbl$date))
flog.info(glue(
"Training window: {min.train.date} - {max.train.date} "
))
flog.info(glue(
"Validation window: {min.valid.date} - {max.valid.date} "
))
flog.info(glue(
"Training window: {min.test.date} - {max.test.date} "
))
# Retrieves the timestamp information
forecast.idx <- test.tbl %>%
tk_index()
train.tbl <- train.tbl %>%
select_if(~ !is.Date(.))
valid.tbl <- valid.tbl %>%
select_if(~ !is.Date(.))
test.tbl <- test.tbl %>%
select_if(~ !is.Date(.))
##
# remove near zero var cols
##
flog.info("Converting to h2oframe objects")
# Convert to H2OFrame objects
train.h2o <- as.h2o(train.tbl)
train.h2o
h2o.feature.data.tbl
new.data.tbl
new.data.tbl$date
forecast.data.cleaned
tail(forecast.data.cleaned)
forecast.data.cleaned %>%
mutate(date = as.Date(floor_date(date + months(optimal.lag.setting, abbreviate = FALSE), unit = "month"))) %>%
mutate(value.lag = unit) %>%
select(date, value.lag), by = c("date")
feature.data.tbl <- inner_join(new.data.tbl, forecast.data.cleaned %>%
mutate(date = as.Date(floor_date(date + months(optimal.lag.setting, abbreviate = FALSE), unit = "month"))) %>%
mutate(value.lag = unit) %>%
select(date, value.lag), by = c("date"))
feature.data.tbl
as.h2o(feature.data.tbl)
train.tbl
feature.data.tbl
as.h2o(train.tbl)
as.h2o(feature.data.tbl)
forecast.data.cleaned <- forecast.data.augmented %>%
clean_names() %>%
remove_empty(c("cols")) %>%
select_if(~ !any(is.na(.))) %>%
mutate_if(is.ordered, ~ as.character(.) %>% as.factor())
# Make future index
new.data.tbl <- forecast.idx %>%
tk_make_future_timeseries(n_future = 12) %>%
tk_get_timeseries_signature() %>%
slice(n) %>%
mutate(date = index) %>%
select(-diff, -index) %>%
clean_names()
new.data.tbl
# Retrieves the timestamp information
forecast.idx <- forecast.data %>%
tk_index()
flog.info("Creating future time indexes")
# Make future index
new.data.tbl <- forecast.idx %>%
tk_make_future_timeseries(n_future = 12) %>%
tk_get_timeseries_signature() %>%
slice(n) %>%
mutate(date = index) %>%
select(-diff, -index) %>%
mutate_if(is.ordered, ~ as.character(.) %>% as.factor()) %>%
clean_names()
flog.info("Creating feature table")
feature.data.tbl <- inner_join(new.data.tbl, forecast.data.cleaned %>%
mutate(date = as.Date(floor_date(date + months(optimal.lag.setting, abbreviate = FALSE), unit = "month"))) %>%
mutate(value.lag = unit) %>%
select(date, value.lag), by = c("date"))
flog.info("Predcting with linear model")
pred.lm <- predict(LM.model$fit.lm, newdata = feature.data.tbl %>%
select_if(~ !is.Date(.)))
final.tbl <- feature.data.tbl %>%
mutate(pred = pred.lm) %>%
select(date, pred)
flog.info("Plotting true forecasts for lm")
TrueForecasts(forecast.data, LM.model$predictions.tbl.lm, final.tbl)
h2o.feature.data.tbl <- feature.data.tbl %>%
select_if(~ !is.Date(.))
flog.info("Predcting with h2o model")
pred.h2o <- predict(H2O.model$automl.leader, newdata = as.h2o(h2o.feature.data.tbl))
final.tbl <- feature.data.tbl %>%
mutate(pred = pred.h2o) %>%
select(date, pred)
pred.h2o
final.tbl <- h2o.feature.data.tbl %>%
mutate(pred = pred.h2o) %>%
select(date, pred)
feature.data.tbl
h2o.feature.data.tbl
pred.h2o
final.tbl <- feature.data.tbl %>%
mutate(pred = pred.h2o) %>%
select(date, pred)
names(feature.data.tbl)
final.tbl <- feature.data.tbl %>%
mutate(pred = pred.lm) %>%
select(date, pred)
final.tbl <- feature.data.tbl %>%
mutate(pred = pred.h2o) %>%
select(date, pred)
pred.h2o
class(pred.h2o)
class(pred.lm)
pred.h2o <- as.numeric(predict(H2O.model$automl.leader, newdata = as.h2o(h2o.feature.data.tbl))) %>%
as.numeric()
pred.h2o <- predict(H2O.model$automl.leader, newdata = as.h2o(h2o.feature.data.tbl)) %>%
as.numeric()
pred.h2o
class(pred.h2o)
as.numeric(pred.h2o)
class(as.numeric(pred.h2o))
data.frame(pred.h2o)
as.vector(pred.h2o)
pred.h2o <- predict(H2O.model$automl.leader, newdata = as.h2o(h2o.feature.data.tbl)) %>%
as.vector()
final.tbl <- feature.data.tbl %>%
mutate(pred = as.numeric(pred.h2o)) %>%
select(date, pred)
flog.info("Plotting true forecasts for h2o")
TrueForecasts(forecast.data, H2O.model$automl.leader, final.tbl)
pred.h2o <- predict(H2O.model$automl.leader, newdata = as.h2o(h2o.feature.data.tbl)) %>%
as.vector()
pred.h2o
final.tbl <- feature.data.tbl %>%
mutate(pred = pred.h2o) %>%
select(date, pred)
flog.info("Plotting true forecasts for h2o")
TrueForecasts(forecast.data, H2O.model$automl.leader, final.tbl)
final.tbl
flog.info("Plotting true forecasts for h2o")
TrueForecasts(forecast.data, H2O.model$automl.leader, final.tbl)
H2O.model
TrueForecasts(forecast.data, H2O.model$predictions.tbl.h2o, final.tbl)
TrueForecasts(forecast.data, LM.model$predictions.tbl.lm, final.tbl)
TrueForecasts(forecast.data, H2O.model$predictions.tbl.h2o, final.tbl)
# Retrieves the timestamp information
forecast.idx <- forecast.data %>%
tk_index()
flog.info("Creating future time indexes")
# Make future index
new.data.tbl <- forecast.idx %>%
tk_make_future_timeseries(n_future = 12) %>%
tk_get_timeseries_signature() %>%
slice(n) %>%
mutate(date = index) %>%
select(-diff, -index) %>%
mutate_if(is.ordered, ~ as.character(.) %>% as.factor()) %>%
clean_names()
flog.info("Creating feature table")
feature.data.tbl <- inner_join(new.data.tbl, forecast.data.cleaned %>%
mutate(date = as.Date(floor_date(date + months(optimal.lag.setting, abbreviate = FALSE), unit = "month"))) %>%
mutate(value.lag = unit) %>%
select(date, value.lag), by = c("date"))
flog.info("Predcting with linear model")
pred.lm <- predict(LM.model$fit.lm, newdata = feature.data.tbl %>%
select_if(~ !is.Date(.)))
final.tbl <- feature.data.tbl %>%
mutate(pred = pred.lm) %>%
select(date, pred)
flog.info("Plotting true forecasts for lm")
TrueForecasts(forecast.data, LM.model$predictions.tbl.lm, final.tbl)
h2o.feature.data.tbl <- feature.data.tbl %>%
select_if(~ !is.Date(.))
flog.info("Predcting with h2o model")
pred.h2o <- predict(H2O.model$automl.leader, newdata = as.h2o(h2o.feature.data.tbl)) %>%
as.vector()
final.tbl <- feature.data.tbl %>%
mutate(pred = pred.h2o) %>%
select(date, pred)
flog.info("Plotting true forecasts for h2o")
TrueForecasts(forecast.data, H2O.model$predictions.tbl.h2o, final.tbl)
usethis::use_tidy_style()
usethis::use_tidy_style()
